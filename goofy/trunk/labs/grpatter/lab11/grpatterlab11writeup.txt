1.) The goal of this lab was to get Goofy to act as a defaulty constructed but to use interrupt handlers to make sure 'bad things' didn't happen. We used interrupt handlers to make sure that goofy didn't continue any action if the signal got cut off at any point. the time interrupt implemented ensured this did not happen. 

2.) We approached this lab by reading through the lab instructions and discussing how to implement (organize) the multiple states for Goofy and how the interrupts affected our previous implementation. We implemented this by adjusting a few global variables to account for changing states while within the interrupt, and by modifying the music function to play based on the timer interrupt and not our own counting procedure.

3.) The biggest issue on this was simply time. Both Jon and I have had networking projects as well as presentations to prepare. As far as the lab itself goes, it was fairly straightforward but EXTREMELY touchy to deal with the interrupts. Small changes affected things in ways that did not seem related at all. The most important part was sitting down and planning the organization of the function calls prior to writing them.

4.) The lab was a bit confusing to understand how to handle the persistent running of the interrupt handlers while we proceded to handle button events as they came in from the user. The interrupt slides were helpful in getting us started, and then the writing of the handlers was fairly easy concept wise. The 'touchy-ness' of the coding scheme was a big hurdle in this lab as sometimes things as trivial as adding a local variable or a print line would affect things in weird ways. Once we had written the handlers, the re-structing of the previously written button event handlers wasn't too confusing, though it was time consuming to chase down all the inconsistencies and weird sitatuations that could occurr.
